# -*- coding: utf-8 -*-
"""Excepciones.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-Es3Is8TlHBAe3vMsW8dcWo68qDBukkP

```
*args y **kwargs
```
"""

def doblar_valor1(numeros):
	numeros[0] *= 2

numeros = [10,20]
doblar_valor1(numeros)
print(numeros)

def doblar_valor(numero):
	numero *= 2

numero = 10
doblar_valor(numero)
print(numero)

def suma(n1,n2):
  return n1+n2

res = suma(3500, n1=1500)
res = suma(n1=10, n2=5)

print(res)

print("Hola", "Mundo", "Mucho gusto","Es mi primer programa")    #por defecto al usar comas los separa con un Espacio y al final con un Enter
print("Hola", "Mundo", "Mucho gusto","Es mi primer programa",sep="*",end="*******************") #ahora separa con "*" (sep) y al final de la linea lo que está en end

name = "Juan"
pais = "Japón"
edad = 25

print("Me llamo",name,"Vivo en",pais,"Y tengo",edad)
print(f"Me llamo {name} Vivo en {pais} Y tengo {edad}")

#*args lo utilizamos cuando no sabemos la cantidad de argumentos que vamos a utilizar al llamar a la función
#sirve para hacer llamadas de argumentos por posición
def sumarElementos(*identificador):  
  return sum(identificador)


def elementos(*args):
  return args   #tupla

res = sumarElementos(1,2,5)
res2 = elementos(1,23,4,5,1,23,13,15,5312,4,214,2)

print(res2)

#**kwargs (keyword args)

def elementos(**kwargs):
  return kwargs   #diccionario

res3 = elementos(n1=0,n2=1,n3=10) #llamando argumentos por nombre (ojo: estamos creando los nombres (keyword))

print(res3)

def saludar():
  return "Hola","Chau",10,2

print(saludar())

def elementos(*loquesea,**loquesea2):
  return loquesea, loquesea2

res4 = elementos(100,3,4,11,"hola", n1=20,clave1="3.14")
print(res4)

print("Hola Mundo")
print("hola")

lista = []

if len(lista)>0:
  lista.pop()

#name = int(input("Ingrese su nombre: "))  #el programador se confundió (esperaba un nombre no un número)


edad = int(input("Ingrese su edad: ")) #programa correcto y el usuario puso un tipo de dato errado

print(edad/2)

n = float(input("Introduce un número: "))
m = 4
print(f"{n}/{m} = {n/m}")

try:

    n = float(input("Ingresar n:\n") ) #input dan una cadena
    m = 4
    print(f"---> {n}/{m} = {n/m}")

except:

  print("Algo salio mal!!! D:")

while True:
    #TRY es obligatorio y except
    try:
      nombre = input("Ingresar su nombre: ")

      n = float(input("Ingresar un numero: "))

    except:
      print("Estas loco no puedo castear esto!!!!")

    #BLOQUE OPCIONAL
    else:  #else se ejecuta cuando no entraste al except

      print("Todo salio bien, gracias")
      break

    #BLOQUE OPCIONAL
    finally:

      print(f"Gracias por estar presente {nombre}")

try:
    n = input("Introduce un número: ")  # no transformamos a número
    
    5/n

except Exception as e1:  # guardamos la excepción como una variable e

    print(f"Ha ocurrido un error => {e1}")
    print(f"Ha ocurrido un error => {type(e1).__name__}")

try:
    		n = float(input("Introduce un número divisor: "))
    		print(5/n)
        
except TypeError:
    		print("No se puede dividir el número entre una cadena")
except ValueError:
    		print("Debes introducir una cadena que sea un número")
except ZeroDivisionError:
    		print("No se puede dividir por cero, prueba otro número")
except Exception as e:
    		print("Ha ocurrido un error no previsto", type(e).__name__ )

def dividir(a,b):

  try: 
    print("----Arrancandooo!!!!!-----")
    a/b

  except:

    print("No se pudo dividir")

  else:

    print("Que bueno que se pudo dividir!!!")

  finally:

    print("Gracias por usar mi función!!!")

#Desafío de errores

def dividir(a, b):
  if b==0:
    return None
  return a/b

n1 = int(input("Ingresa un número: "))
n2 = int(input("Ingresa otro número: "))

resultado = dividir(n1,n2)

def dividir(a, b):
    return a/b

n1 = int(input("Ingresa un número: "))
n2 = int(input("Ingresa otro número: "))


try:
  resultado = dividir(n1,n2)
  print(resultado)

except:
  print("No se puede dividir entre cero")